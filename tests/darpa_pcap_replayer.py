"""
    Replays packets from PCAP Captured from
    Trails.
"""
import dpkt
import os
import datetime
import socket


class NetworkData(object):

    def __init__(self, target_data, target_timestamp):
        """
            Create a new NetworkData object.
        :param target_data: data of the current object.
        :return: None
        """
        self.target_data = target_data
        self._is_input = False
        self._is_output = False
        self.target_timestamp = target_timestamp

    @property
    def is_input(self):
        """
            Flag to indicate if this network data object is input
        :return: true/false depending on whether the current object is input.
        """
        return self._is_input

    @property
    def is_output(self):
        """
            Flag to indicate if this network data object is output
        :return: true/false depending on whether the current object is output.
        """
        return self._is_output

    @property
    def data(self):
        """
            Get data corresponding to current object.
        :return: data
        """
        return self.target_data


class InputData(NetworkData):
    """
        Represents Input data
    """

    def __init__(self, target_data, target_timestamp):
        NetworkData.__init__(self, target_data, target_timestamp)
        self._is_input = True


class OutputData(NetworkData):
    """
        Represents output data
    """

    def __init__(self, target_data, target_timestamp):
        NetworkData.__init__(self, target_data, target_timestamp)
        self._is_output = True


class TCPStream(object):
    """
        Represents a TCP Stream.
    """

    def __init__(self, src_ip, dst_ip, data_pkts):
        self.src_ip = src_ip
        self.dst_ip = dst_ip
        self.data_pkts = data_pkts


class PcapParser(object):
    """
        This class parses the provided PCAP file into a stream.
        Note: This is used only to parse the PCAP generated by cb-test.
    """

    def __init__(self, target_pcap_file):
        """
            Create a Parser object.
        :param target_pcap_file: Path to the PCAP file.
        :return:
        """
        assert os.path.exists(target_pcap_file), "Provided PCAP File:" + str(target_pcap_file) + " does not exists"
        pcap_fp = open(target_pcap_file, 'rb')
        pcap_iter = dpkt.pcap.Reader(pcap_fp)
        self.all_pkts = list(pcap_iter)
        pcap_fp.close()

    def get_data_stream(self):
        """
            Get the stream associated with the PCAP.
        :return: TCPStream corresponding to the provided PCAP file.
        """
        target_stream = None
        if len(self.all_pkts) > 0:
            first_eth_pkt = dpkt.ethernet.Ethernet(self.all_pkts[0][1])
            src_ip = first_eth_pkt.data.src
            dst_ip = first_eth_pkt.data.dst
            prev_time_stamp = datetime.datetime.utcfromtimestamp(self.all_pkts[0][0])
            all_pkts = []
            for i in range(0, len(self.all_pkts)):
                target_timestamp = datetime.datetime.utcfromtimestamp(self.all_pkts[i][0])
                curr_raw_pkt = dpkt.ethernet.Ethernet(self.all_pkts[i][1])
                curr_src = curr_raw_pkt.data.src
                curr_dst = curr_raw_pkt.data.dst
                curr_data = curr_raw_pkt.data.data.data
                if (target_timestamp - prev_time_stamp).total_seconds() > 1.0:
                    all_pkts.append("delay:" + str((target_timestamp - prev_time_stamp).total_seconds()))
                prev_time_stamp = target_timestamp
                if len(curr_data) > 0:
                    if curr_src == src_ip:
                        if curr_dst != dst_ip:
                            print("[!] Got a packet whose destination is unknown:" + str(curr_dst) +
                                  ", Expected:" + str(dst_ip))
                        curr_data_pkt = InputData(curr_data, target_timestamp)
                    else:
                        if curr_dst != src_ip:
                            print("[!] Got a packet whose destination is unknown:" + str(curr_dst) +
                                  ", Expected:" + str(src_ip))
                        curr_data_pkt = OutputData(curr_data, target_timestamp)
                    all_pkts.append(curr_data_pkt)
            target_stream = TCPStream(src_ip, dst_ip, all_pkts)

        return target_stream

import sys
target_pcap_file = sys.argv[1]
dst_ip = sys.argv[2]
dest_port = int(sys.argv[3])
tpcap = PcapParser(target_pcap_file)
target_d_stream = tpcap.get_data_stream()
sock1 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for i in range(len(target_d_stream.data_pkts)):
    curr_pkt = target_d_stream.data_pkts[i]
    if isinstance(curr_pkt, str) and curr_pkt.startswith('delay:'):
        to_sleep_time = float(curr_pkt.split('delay:')[1])
        print "Sleeping for:" + str(to_sleep_time) + " Seconds."
        import time
        time.sleep(to_sleep_time)
    else:
        sock1.sendto(curr_pkt.data, (dst_ip, dest_port))
